<!DOCTYPE html>
<meta charset="utf-8">
<title>POE Skill Builder</title>
<body>
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script>

    // total increments for each ring
    const ring1Incr = 12;
    const ring2Incr = 24;
    const ring3Incr = 40;
    //radius scale
    const radiusLength = 50;

    // TEST DATA: change these values to make sure it works as intended
    const testRadius = 1; // 1, 2, or 3
    const testIndex = 3; // 0-12 for radius = 1; 0-24 for radius = 2; 0-40 for radius = 3; (see above ring consts)

    /**
     * Takes a point and information about the second point and produces the inferred coordinates for
     * the second point.
     * @param centerCoord Center coordinate from which the second will be referenced from.
     * @param orbitalRadius Integer value 1 - 3 representing which ring the second point will be on.
     * @param orbitalIndex Integer value representing the position on orbitalRadius. This value's range is dependant
     * on the ring increment constants above.
     * @returns {*} {x, y} object with coordinates of second point.
     */
    function getCoords(centerCoord, orbitalRadius, orbitalIndex){
        var degreeIncrement = 0;

        // figure out how many rads between indices
        switch(orbitalRadius){
            case 1:
                degreeIncrement = (Math.PI * 2) / ring1Incr;
                break;
            case 2:
                degreeIncrement = (Math.PI * 2) / ring2Incr;
                break;
            case 3:
                degreeIncrement = (Math.PI * 2) / ring3Incr;
                break;
            default:
                window.alert("Invalid radius. The radius must be either 1, 2, or 3.");
                return null;
        }

        angle = 0 - (degreeIncrement * orbitalIndex) - (Math.PI);
        radius = orbitalRadius * radiusLength;

        var x = centerCoord.x + radius * Math.sin(angle);
        var y = centerCoord.y + radius * Math.cos(angle);

        return {x: x, y: y};
    }

    var width = 960, height = 800;

    var randomX = d3.random.normal(width / 2, 80),
            randomY = d3.random.normal(height / 2, 80);

    var data = d3.range(1).map(function () {
        return [
            randomX(),
            randomY()
        ];
    });

    var x = d3.scale.linear()
            .domain([0, width])
            .range([0, width]);

    var y = d3.scale.linear()
            .domain([0, height])
            .range([height, 0]);

    var canvas = d3.select("body").append("canvas")
            .attr("width", width)
            .attr("height", height)
            .call(d3.behavior.zoom().x(x).y(y).scaleExtent([1, 8]).on("zoom", zoom))
            .node().getContext("2d");

    draw();

    function zoom() {
        canvas.clearRect(0, 0, width, height);
        draw();
    }

    function draw() {
        var i = -1, n = data.length, d, cx, cy;
        canvas.beginPath();
        while (++i < n) {
            d = data[i];
            cx = x(d[0]);
            cy = y(d[1]);
            canvas.moveTo(cx, cy);
            canvas.arc(cx, cy, 2.5, 0, 2 * Math.PI);

            // TESTING
            newCoord = getCoords({x: cx, y: cy}, testRadius, testIndex);
            canvas.moveTo(x(newCoord.x), y(newCoord.y));
            canvas.arc(newCoord.x, newCoord.y, 4.5, 0, 2 * Math.PI);
        }
        canvas.fill();
    }

</script>
</body>
RAW Paste Data

<!DOCTYPE html>
<meta charset="utf-8">
<title>POE Skill Builder</title>
<body>
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script>

    // total increments for each ring
    const ring1Incr = 12;
    const ring2Incr = 24;
    const ring3Incr = 40;
    //radius scale
    const radiusLength = 50;

    // TEST DATA: change these values to make sure it works as intended
    const testRadius = 1; // 1, 2, or 3
    const testIndex = 3; // 0-12 for radius = 1; 0-24 for radius = 2; 0-40 for radius = 3; (see above ring consts)

    /**
     * Takes a point and information about the second point and produces the inferred coordinates for
     * the second point.
     * @param centerCoord Center coordinate from which the second will be referenced from.
     * @param orbitalRadius Integer value 1 - 3 representing which ring the second point will be on.
     * @param orbitalIndex Integer value representing the position on orbitalRadius. This value's range is dependant
     * on the ring increment constants above.
     * @returns {*} {x, y} object with coordinates of second point.
     */
    function getCoords(centerCoord, orbitalRadius, orbitalIndex){
        var degreeIncrement = 0;

        // figure out how many rads between indices
        switch(orbitalRadius){
            case 1:
                degreeIncrement = (Math.PI * 2) / ring1Incr;
                break;
            case 2:
                degreeIncrement = (Math.PI * 2) / ring2Incr;
                break;
            case 3:
                degreeIncrement = (Math.PI * 2) / ring3Incr;
                break;
            default:
                window.alert("Invalid radius. The radius must be either 1, 2, or 3.");
                return null;
        }

        angle = 0 - (degreeIncrement * orbitalIndex) - (Math.PI);
        radius = orbitalRadius * radiusLength;

        var x = centerCoord.x + radius * Math.sin(angle);
        var y = centerCoord.y + radius * Math.cos(angle);

        return {x: x, y: y};
    }

    var width = 960, height = 800;

    var randomX = d3.random.normal(width / 2, 80),
            randomY = d3.random.normal(height / 2, 80);

    var data = d3.range(1).map(function () {
        return [
            randomX(),
            randomY()
        ];
    });

    var x = d3.scale.linear()
            .domain([0, width])
            .range([0, width]);

    var y = d3.scale.linear()
            .domain([0, height])
            .range([height, 0]);

    var canvas = d3.select("body").append("canvas")
            .attr("width", width)
            .attr("height", height)
            .call(d3.behavior.zoom().x(x).y(y).scaleExtent([1, 8]).on("zoom", zoom))
            .node().getContext("2d");

    draw();

    function zoom() {
        canvas.clearRect(0, 0, width, height);
        draw();
    }

    function draw() {
        var i = -1, n = data.length, d, cx, cy;
        canvas.beginPath();
        while (++i < n) {
            d = data[i];
            cx = x(d[0]);
            cy = y(d[1]);
            canvas.moveTo(cx, cy);
            canvas.arc(cx, cy, 2.5, 0, 2 * Math.PI);

            // TESTING
            newCoord = getCoords({x: cx, y: cy}, testRadius, testIndex);
            canvas.moveTo(x(newCoord.x), y(newCoord.y));
            canvas.arc(newCoord.x, newCoord.y, 4.5, 0, 2 * Math.PI);
        }
        canvas.fill();
    }

</script>
</body>